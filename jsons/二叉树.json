{
  "topic": "二叉树",
  "content": {
    "application": "1、 查找树\n  查找树（Search Tree）又称搜索树，是一种有查找功能的二叉树，能够在O(logn)时间复杂度内完成查找。\n  \n  查找树的关键字不重复，查找树是递归定义的：\n  \n  空树是查找树。\n  \n  如果左子树是查找树，其关键字均小于根节点的关键字；\n  \n  如果右子树是查找树，其关键字均大于根节点的关键字。\n  \n  如果左、右子树都是查找树，则左、右子树的根节点的关键字分别小于、大于根节点的关键字。\n  \n  在查找树中查找某个关键字的查找时间复杂度为O(logn)。\n  \n  查找树的具体应用：\n  \n  二叉搜索树\n  \n  平衡二叉搜索树\n  \n  红黑树\n  \n  伸展树\n  \n  2、 表达式树\n  表达式树是二叉树的一种，它是通过二叉树来表示各种表达式，它可以用来进行表达式的计算。\n  \n  表达式树可以用来进行表达式的计算，因为它可以将一个表达式分解成一颗树，然后按照树的遍历顺序进行计算。\n  \n  表达式树的具体应用：\n  \n  编译器\n  \n  游戏引擎\n  \n  3、 哈夫曼树\n  哈夫曼树（Huffman Tree）是带权路径最短的二叉树，它是用来进行数据压缩的一种算法。\n  \n  哈夫曼树的具体应用：\n  \n  数据压缩\n  \n  数据加密\n  \n  4、 线段树\n  线段树是一种用于动态查询的数据结构，它可以用来进行区间查询和区间更新。\n  \n  线段树的具体应用：\n  \n  区间查询\n  \n  区间更新\n  \n  5、 并查集\n  并查集是一种用来进行集合操作的数据结构，它可以用来进行集合的合并和查找。\n  \n  并查集的具体应用：\n  \n  集合的合并\n  \n  集合的查找\n  \n  6、 红黑树\n  红黑树是一种平衡二叉树，它是一种用于动态查找的数据结构，它可以用来进行动态查找。\n  \n  红黑树的具体应用：\n  \n  动态查找\n  \n  动态更新\n  \n  7、 斐波那契堆\n  斐波那契堆是一种用来进行堆操作的数据结构，它可以用来进行堆的插入、删除和合并。\n  \n  斐波那契堆的具体应用：\n  \n  堆的插入\n  \n  堆的删除\n  \n  堆的合并\n  \n  8、 可持久化数据结构\n  可持久化数据结构是一种用来进行数据操作的数据结构，它可以用来进行数据的插入、删除和查找。\n  \n  可持久化数据结构的具体应用：\n  \n  数据的插入\n  \n  数据的删除\n  \n  数据的查找\n  \n  9、 字典树\n  字典树是一种用于字符串查找的数据结构，它可以用来进行字符串的插入、删除和查找。\n  \n  字典树的具体应用：\n  \n  字符串的插入\n  \n  字符串的删除\n  \n  字符串的查找\n  \n  10、 跳表\n  跳表是一种用来进行动态查找的数据结构，它可以用来进行动态查找。\n  \n  跳表的具体应用：\n  \n  动态查找\n  \n  动态更新\n  \n  11、 平衡二叉树\n  平衡二叉树是一种用来进行动态查找的数据结构，它可以用来进行动态查找。\n  \n  平衡二叉树的具体应用：\n  \n  动态查找\n  \n  动态更新\n  \n  12、 布隆过滤器\n  布隆过滤器是一种用来进行数据查找的数据结构，它可以用来进行数据的插入和查找。\n  \n  布隆过滤器的具体应用：\n  \n  数据的插入\n  \n  数据的查找\n  \n  13、 并发队列\n  并发队列是一种用来进行数据操作的数据结构，它可以用来进行数据的插入和删除。\n  \n  并发队列的具体应用：\n  \n  数据的插入\n  \n  数据的删除\n  \n  14、 并发栈\n  并发栈是一种用来进行数据操作的数据结构，它可以用来进行数据的插入和删除。\n  \n  并发栈的具体应用：\n  \n  数据的插入\n  \n  数据的删除\n  \n  15、 并发哈希表\n  并发哈希表是一种用来进行数据操作的数据结构，它可以用来进行数据的插入和删除。\n  \n  并发哈希表的具体应用：\n  \n  数据的插入\n  \n  数据的删除\n  \n  16、 并发链表\n  并发链表是一种用来进行数据操作的数据结构，它可以用来进行数据的插入和删除。\n  \n  并发链表的具体应用：\n  \n  数据的插入\n  \n  数据的删除\n  \n  17、 并发数组\n  并发数组是一种用来进行数据操作的数据结构，它可以用来进行数据的插入和删除。\n  \n  并发数组的具体应用：\n  \n  数据的插入\n  \n  数据的删除\n  \n  18、 并发树\n  并发树是一种用来进行数据操作的数据结构，它可以用来进行数据的插入和删除。\n  \n  并发树的具体应用：\n  \n  数据的插入\n  \n  数据的删除\n  \n  19、 并发图\n  并发图是一种用来进行数据操作的数据结构，它可以用来进行数据的插入和删除。\n  \n  并发图的具体应用：\n  \n  数据的插入\n  \n  数据的删除\n  \n  20、 并发堆\n  并发堆是一种用来进行数据操作的数据结构，它可以用来进行数据的插入和删除。\n  \n  并发堆的具体应用：\n  \n  数据的插入\n  \n  数据的删除\n  \n  二叉树的应用场景：\n  \n  查找树\n  \n  表达式树\n  \n  哈夫曼树\n  \n  线段树\n  \n  并查集\n  \n  红黑树\n  \n  斐波那契堆\n  \n  可持久化数据结构\n  \n  字典树\n  \n  跳表\n  \n  平衡二叉树\n  \n  布隆过滤器\n  \n  并发队列\n  \n  并发栈\n  \n  并发哈希表\n  \n  并发链表\n  \n  并发数组\n  \n  并发树\n  \n  并发图\n  \n  并发堆\n  \n  二叉树的应用场景，可以用于多种不同的场景，包括查找、排序、索引、搜索、数据库、图形、游戏等。\n  \n  二叉树的应用场景，可以用于多种不同的场景，包括查找、排序、索引、搜索、数据库、图形、游戏等。\n  \n  二叉树的应用场景，可以用于多种不同的场景，包括查找、排序、索引、搜索、数据库、图形、游戏等。\n  \n  二叉树的应用场景，可以用于多种不同的场景，包括查找、排序、索引、",
    "code": "# 二叉树节点\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n# 二叉树\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # 插入节点\n    def insert(self, val):\n        if self.root is None:\n            self.root = TreeNode(val)\n        else:\n            self._insert(val, self.root)\n\n    def _insert(self, val, node):\n        if val < node.val:\n            if node.left is None:\n                node.left = TreeNode(val)\n            else:\n                self._insert(val, node.left)\n        else:\n            if node.right is None:\n                node.right = TreeNode(val)\n            else:\n                self._insert(val, node.right)\n\n    # 前序遍历\n    def preorder_traversal(self):\n        result = []\n        self._preorder_traversal(self.root, result)\n        return result\n\n    def _preorder_traversal(self, node, result):\n        if node is not None:\n            result.append(node.val)\n            self._preorder_traversal(node.left, result)\n            self._preorder_traversal(node.right, result)\n\n    # 中序遍历\n    def inorder_traversal(self):\n        result = []\n        self._inorder_traversal(self.root, result)\n        return result\n\n    def _inorder_traversal(self, node, result):\n        if node is not None:\n            self._inorder_traversal(node.left, result)\n            result.append(node.val)\n            self._inorder_traversal(node.right, result)\n\n    # 后序遍历\n    def postorder_traversal(self):\n        result = []\n        self._postorder_traversal(self.root, result)\n        return result\n\n    def _postorder_traversal(self, node, result):\n        if node is not None:\n            self._postorder_traversal(node.left, result)\n            self._postorder_traversal(node.right, result)\n            result.append(node.val)\n\n# 示例\nif __name__ == '__main__':\n    # 创建一个二叉树\n    tree = BinaryTree()\n\n    # 插入节点\n    tree.insert(5)\n    tree.insert(3)\n    tree.insert(7)\n    tree.insert(1)\n    tree.insert(4)\n    tree.insert(6)\n    tree.insert(8)\n\n    # 前序遍历\n    preorder_result = tree.preorder_traversal()\n    print(\"前序遍历结果:\", preorder_result)\n\n    # 中序遍历\n    inorder_result = tree.inorder_traversal()\n    print(\"中序遍历结果:\", inorder_result)\n\n    # 后序遍历\n    postorder_result = tree.postorder_traversal()\n    print(\"后序遍历结果:\", postorder_result)",
    "comparison": "### 数据结构\n\n- 数组\n\n数组（Array）是最简单的数据结构，但它也有缺点，比如删除、插入操作需要移动大量元素。\n\n数组的优点是，根据下标随机访问的时间复杂度为O(1)，这是数组能够高效支持随机访问的关键。\n\n- 链表\n\n链表（Linked List）是另外一种线性表，它内部的存储结构是分散的，通过指针来连接各个元素。\n\n链表的缺点是，访问其中一个元素的耗时是O(n)，因为需要从头节点开始，依次访问n个节点。\n\n- 栈（Stack）\n\n栈是一种后进先出的数据结构（LIFO），只允许在一端插入和删除数据。\n\n栈可以用来存储函数调用信息，比如函数的参数、返回地址和临时变量。\n\n栈是递归的基础，在递归中，我们需要维护一个栈来存储函数调用信息。\n\n- 队列（Queue）\n\n队列是一种先进先出的数据结构（FIFO），允许在一端插入，另一端删除数据。\n\n队列常用于处理多线程，或者并发编程中。\n\n- 散列表（Hash）\n\n散列表是根据关键码值而直接进行访问的数据结构，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。\n\n散列表存储的是键值对，通过键可以快速的获取对应的值。\n\n- 树（Tree）\n\n树是一种数据结构，它是一种分层的数据模型，每个节点都有一个父节点和零个或多个子节点，除根节点外，每个节点都有且只有一个父节点。\n\n树的所有节点可以通过一个根节点相连。\n\n树可以用来描述任何类型的数据结构，比如文件系统、函数调用、计算机网络等。\n\n- 图（Graph）\n\n图是一种网络模型，由一系列顶点（Vertex）和边（Edge）组成，用来模拟现实世界中的物体之间的关系。\n\n图可以用来表示任何数据结构，比如地图、社交网络等。\n\n### 数据结构对比\n\n| 数据结构 | 存储方式 | 读取 | 插入 | 删除 |\n| --- | --- | --- | --- | --- |\n| 数组 | 连续内存空间 | 随机访问 | 插入、删除 | 插入、删除 |\n| 链表 | 零散内存空间 | 线性查找 | 插入、删除 | 插入、删除 |\n| 树 | 零散内存空间 | 深度优先遍历 | 插入、删除 | 插入、删除 |\n| 图 | 零散内存空间 | 广度优先遍历 | 插入、删除 | 插入、删除 |\n| 栈 | 连续内存空间 | 访问栈顶元素 | 入栈 | 出栈 |\n| 队列 | 连续内存空间 | 访问队列首元素 | 入队 | 出队 |\n| 散列表 | 散列表 | 通过散列函数获取值 | 插入、删除 | 插入、删除 |",
    "concept": "二叉树（Binary Tree）是树形结构的一种，是每个结点最多只有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。\n二叉树的性质\n二叉树的性质（基本性质）\n1.二叉树第i层的最大结点数为2i-1。\n2.深度为k的二叉树最多有2k-1个结点。\n3.对于任何一棵非空二叉树T，如果叶子结点的个数为N0，度为2的结点总数为N2，则：N0 = N2 + 1。\n4.具有n个结点的完全二叉树的深度为log2(n+1)。\n5.如果对完全二叉树从上到下从左到右进行编号，对于任意结点i，有：\n若i=1，则结点i是二叉树的根，无双亲；若i>1，则其双亲为i/2，左右孩子分别为2i和2i+1。\n6.具有n个结点的完全二叉树的结点按层次从上到下从左到右编号为1~n，则对任一结点i，有：\n若i=1，则为根，无双亲；若i>1，则其双亲为i/2，左右孩子分别为2i和2i+1。\n二叉树的存储结构\n1.顺序存储：\n对于完全二叉树，用一维数组存储二叉树。\n2.链式存储：\n对于二叉树，采用链式存储结构，用两个链表分别存储左右子树的指针。\n二叉树的遍历\n1.前序遍历（preorder traversal）：先访问根结点，然后前序遍历左子树，最后前序遍历右子树。\n2.中序遍历（inorder traversal）：先中序遍历左子树，然后访问根结点，最后中序遍历右子树。\n3.后序遍历（postorder traversal）：先后序遍历左子树，然后后序遍历右子树，最后访问根结点。\n4.层序遍历（level order traversal）：从根结点开始，自上而下，自左向右访问每一个结点。\n二叉树的二叉链表存储表示\n在二叉链表中，每个结点包含三个域：数据域，左孩子域，右孩子域。\n二叉树的二叉树的创建\n1.先序遍历：先创建根结点，然后递归创建左子树，最后递归创建右子树。\n2.中序遍历：先递归创建左子树，然后创建根结点，最后递归创建右子树。\n3.后序遍历：先递归创建左子树，然后递归创建右子树，最后创建根结点。\n二叉树的线索二叉树\n线索二叉树（threaded binary tree），即对二叉树中的结点，除有左右孩子的指针外，增加一个指向其前驱和后继的指针。\n线索化方法：\n1.中序线索化：对二叉树进行中序遍历，当访问结点p时，根据p的左右孩子指针情况，确定对p进行线索化的方式。\n2.后序线索化：对二叉树进行后序遍历，当访问结点p时，根据p的左右孩子指针情况，确定对p进行线索化的方式。\n二叉树的二叉排序树\n二叉排序树（binary sort tree），也称为二叉查找树（binary search tree）。\n1.若左子树不为空，则左子树上所有结点的值均小于根结点的值。\n2.若右子树不为空，则右子树上所有结点的值均大于根结点的值。\n3.左右子树也为二叉排序树。\n二叉排序树的创建：\n1.若二叉排序树为空，则将插入的结点作为根结点。\n2.若二叉排序树不为空，则比较插入的结点与根结点的值：\n若插入的结点的值小于根结点的值，则将插入的结点插入到根结点的左子树中。\n若插入的结点的值大于根结点的值，则将插入的结点插入到根结点的右子树中。\n3.重复上述步骤，直到插入成功。\n二叉排序树的查找：\n1.若二叉排序树为空，则查找失败。\n2.若二叉排序树不为空，则比较查找的结点与根结点的值：\n若查找的结点的值等于根结点的值，则查找成功。\n若查找的结点的值小于根结点的值，则查找左子树。\n若查找的结点的值大于根结点的值，则查找右子树。\n3.重复上述步骤，直到查找成功或查找失败。\n二叉排序树的删除：\n1.若二叉排序树为空，则删除失败。\n2.若二叉排序树不为空，则比较删除的结点与根结点的值：\n若删除的结点的值等于根结点的值，则删除根结点。\n若删除的结点的值小于根结点的值，则删除左子树。\n若删除的结点的值大于根结点的值，则删除右子树。\n3.重复上述步骤，直到删除成功或删除失败。\n二叉排序树的修改：\n1.若二叉排序树为空，则修改失败。\n2.若二叉排序树不为空，则比较修改的结点与根结点的值：\n若修改的结点的值等于根结点的值，则修改根结点。\n若修改的结点的值小于根结点的值，则修改左子树。\n若修改的结点的值大于根结点的值，则修改右子树。\n3.重复上述步骤，直到修改成功或修改失败。\n二叉排序树的查找效率：\n1.若二叉排序树为空，则查找失败。\n2.若二叉排序树不为空，则比较查找的结点与根结点的值：\n若查找的结点的值等于根结点的值，则查找成功。\n若查找的结点的值小于根结点的值，则查找左子树。\n若查找的结点的值大于根结点的值，则查找右子树。\n3.重复上述步骤，直到查找成功或查找失败。\n二叉排序树的查找效率：\n1.若二叉排序树为空，则查找失败。\n2.若二叉排序树不为空，则比较查找的结点与根结点的值：\n若查找的结点的值等于根结点的值，则查找成功。\n若查找的结点的值小于根结点的值，则查找左子树。\n若查找的结点的值大于根结点的值，则查找右子树。\n3.重复上述步骤，直到查找成功或查找失败。\n二叉排序树的查找效率：\n1.若二叉排序树为空，则查找失败。\n2.若二叉排序树不为空，则比较查找的结点与根结点的值：\n若查找的结点的值等于根结点的值，则查找成功。\n若查找的结点的值小于根结点的值，则查找左子树。\n若查找的结点的值大于根结点的值，则查找右子树。\n3.重复上述步骤，直到查找成功或查找失败。\n二叉排序树的查找效率：\n1.若二叉排序树为空，则查找失败。\n2.若二叉排序树不为空，则比较查找的结点与根结点的值：",
    "traversal": "### 前序遍历\n```java\nvoid preOrder(TreeNode root){\n  if(root==null){\n    return;\n  }\n  visit(root);\n  preOrder(root.left);\n  preOrder(root.right);\n}\n```\n\n### 中序遍历\n```java\nvoid inOrder(TreeNode root){\n  if(root==null){\n    return;\n  }\n  inOrder(root.left);\n  visit(root);\n  inOrder(root.right);\n}\n```\n\n### 后序遍历\n```java\nvoid postOrder(TreeNode root){\n  if(root==null){\n    return;\n  }\n  postOrder(root.left);\n  postOrder(root.right);\n  visit(root);\n}\n```\n\n### 层序遍历\n```java\nvoid levelOrder(TreeNode root){\n  if(root==null){\n    return;\n  }\n  Queue<TreeNode> queue=new LinkedList<>();\n  queue.add(root);\n  while(!queue.isEmpty()){\n    TreeNode node=queue.poll();\n    visit(node);\n    if(node.left != null) {\n      queue.add(node.left);\n    }\n    if(node.right != null) {\n      queue.add(node.right);\n    }\n  }\n}\n```"
  }
}