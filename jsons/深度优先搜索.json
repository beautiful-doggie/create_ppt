{
  "topic": "深度优先搜索",
  "content": {
    "application": "### 概念\n\n**深度优先搜索**（Depth-First Search）\n\n- 是一种用于遍历或搜索树或图的算法。\n- 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。\n- 如果节点v的所有边都己被探查过，搜索将回溯到发现节点v的那条边的节点。\n\n### 应用场景\n\n#### 1、找出所有路径\n\n![2021-05-25_153349](https://raw.githubusercontent.com/Sono-J/images-bed/main/blog/2021-05-25_153349.png)\n\n#### 2、找出所有路径的总和等于目标值的路径\n\n![2021-05-25_153356](https://raw.githubusercontent.com/Sono-J/images-bed/main/blog/2021-05-25_153356.png)\n\n#### 3、找出所有满足条件的节点\n\n![2021-05-25_153402](https://raw.githubusercontent.com/Sono-J/images-bed/main/blog/2021-05-25_153402.png)\n\n#### 4、找出最短路径\n\n![2021-05-25_153407](https://raw.githubusercontent.com/Sono-J/images-bed/main/blog/2021-05-25_153407.png)\n\n#### 5、找出所有满足条件的叶子节点\n\n![2021-05-25_153411](https://raw.githubusercontent.com/Sono-J/images-bed/main/blog/2021-05-25_153411.png)\n\n#### 6、找出所有满足条件的路径\n\n![2021-05-25_153418](https://raw.githubusercontent.com/Sono-J/images-bed/main/blog/2021-05-25_153418.png)\n\n#### 7、找出所有满足条件的路径\n\n![2021-05-25_153423](https://raw.githubusercontent.com/Sono-J/images-bed/main/blog/2021-05-25_153423.png)\n\n### 实现代码\n\n```js\nconst root = {\n    val: 1,\n    children: [\n        {\n            val: 2,\n            children: [\n                {\n                    val: 5,\n                    children: []\n                },\n                {\n                    val: 6,\n                    children: []\n                }\n            ]\n        },\n        {\n            val: 3,\n            children: [\n                {\n                    val: 7,\n                    children: []\n                },\n                {\n                    val: 8,\n                    children: []\n                }\n            ]\n        },\n        {\n            val: 4,\n            children: []\n        }\n    ]\n}\n\n// 深度优先搜索\nfunction dfs(root, target, path, res) {\n    if (!root) return\n\n    path.push(root.val)\n    // 满足条件则将路径加入到res中\n    if (root.val === target) {\n        res.push(path.slice())\n    }\n    // 遍历当前节点的所有子节点\n    for (const child of root.children) {\n        dfs(child, target, path, res)\n    }\n    // 回溯\n    path.pop()\n}\n\nconst pathSum = (root, targetSum) => {\n    const res = []\n    dfs(root, targetSum, [], res)\n    return res\n}\n\nconsole.log(pathSum(root, 10))\n```\n\n### 题目\n\n- [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)\n- [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)\n- [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)\n- [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)\n- [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n- [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n### 参考\n\n- [深度优先搜索（DFS）与广度优先搜索（BFS）](https://zhuanlan.zhihu.com/p/41334483)\n- [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/solution/113-lu-jing-zong-he-ii-dfs-by-jyd/)\n- [112. 路径总和](https://leetcode-cn.com/problems/path-sum/solution/112-lu-jing-zong-he-by-jyd/)\n- [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/111-er-cha-shu-de-zui-xiao-shen-du-by-jyd/)\n- [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/solution/110-ping-heng-er-cha-shu-by-jyd/)\n- [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/104-er-cha-shu-de-zui-da-shen-du-by-jyd/)\n- [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/solution/110-ping-heng-er-cha-shu-by-jyd/)\n- [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/solution/113-lu-jing-zong-he-ii-dfs-by-jyd/)\n- [112. 路径总和](https://leetcode-cn.com/problems/path-sum/solution/112-lu-jing-zong-he-by-jyd/)\n- [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/111-er-cha-shu-de-zui-xiao-shen-du-by-jyd/)\n- [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/solution/110-ping-heng-er-cha-shu-by-jyd/)\n- [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/104-er-cha-shu-de-zui-da-shen-du-by-jyd/)\n- [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/solution/110-ping-heng-er-cha-shu-by-jyd/)\n- [113. 路径总和 II](https://leetcode-cn.com/problems/path-",
    "code": "图的遍历：\n深度优先搜索（DFS）是图论中的一种搜索算法。\n它的基本思想是：从图中某个顶点出发，沿着路径深入到图的深处，直到路径上出现死胡同为止，然后再退回分叉路口，另选一条路径，继续深入，直到遍历完整个图。\nDFS 在遍历时，首先把初始点放入栈中，然后从栈顶开始，依次把它的所有未被访问的邻接点放入栈中，直到栈为空。\n\n# 图的遍历\n\n图的遍历就是对图中所有顶点进行访问，从而达到对图的访问目的。\n\n## 图的遍历的基本操作\n\n- 添加顶点（Vertex）：添加一个顶点\n- 删除顶点（Vertex）：删除一个顶点\n- 添加边（Edge）：添加一条边\n- 删除边（Edge）：删除一条边\n- 获得邻接点（Adjacent）：获得某个顶点的所有邻接点\n- 获得顶点数（Vertex）：获得图的顶点数\n- 获得边数（Edge）：获得图的边数\n- 清空（Clear）：清空图\n- 获得邻接矩阵（Adjacency Matrix）：获得图的邻接矩阵\n- 获得邻接表（Adjacency List）：获得图的邻接表\n- 深度优先遍历（Depth First Traversal）：深度优先遍历\n- 广度优先遍历（Breadth First Traversal）：广度优先遍历\n\n## 图的遍历的基本操作实现\n\n### 1. 添加顶点（Vertex）\n\n```python\ndef add_vertex(self, v):\n    if v in self.vertices:\n        raise ValueError(\"Vertex {} already exists\".format(v))\n    else:\n        self.vertices.add(v)\n        for row in self.adjacency_matrix:\n            row.append(0)\n        self.adjacency_matrix.append([0] * (len(self.vertices) + 1))\n        self.adjacency_matrix[v][v] = 1\n```\n\n### 2. 删除顶点（Vertex）\n\n```python\ndef remove_vertex(self, v):\n    if v not in self.vertices:\n        raise ValueError(\"Vertex {} does not exist\".format(v))\n    else:\n        self.vertices.remove(v)\n        self.adjacency_matrix.pop(v)\n        for row in self.adjacency_matrix:\n            row.pop(v)\n```\n\n### 3. 添加边（Edge）\n\n```python\ndef add_edge(self, v1, v2, weight=1):\n    if v1 not in self.vertices:\n        raise ValueError(\"Vertex {} does not exist\".format(v1))\n    elif v2 not in self.vertices:\n        raise ValueError(\"Vertex {} does not exist\".format(v2))\n    else:\n        self.adjacency_matrix[v1][v2] = weight\n        self.adjacency_matrix[v2][v1] = weight\n```\n\n### 4. 删除边（Edge）\n\n```python\ndef remove_edge(self, v1, v2):\n    if v1 not in self.vertices:\n        raise ValueError(\"Vertex {} does not exist\".format(v1))\n    elif v2 not in self.vertices:\n        raise ValueError(\"Vertex {} does not exist\".format(v2))\n    else:\n        self.adjacency_matrix[v1][v2] = 0\n        self.adjacency_matrix[v2][v1] = 0\n```\n\n### 5. 获得邻接点（Adjacent）\n\n```python\ndef get_adjacent_vertices(self, v):\n    if v not in self.vertices:\n        raise ValueError(\"Vertex {} does not exist\".format(v))\n    else:\n        adjacent_vertices = []\n        for i in range(len(self.vertices)):\n            if self.adjacency_matrix[v][i] > 0:\n                adjacent_vertices.append(i)\n        return adjacent_vertices\n```\n\n### 6. 获得顶点数（Vertex）\n\n```python\ndef get_vertices(self):\n    return self.vertices\n```\n\n### 7. 获得边数（Edge）\n\n```python\ndef get_edges(self):\n    edges = []\n    for i in range(len(self.vertices)):\n        for j in range(i+1, len(self.vertices)):\n            if self.adjacency_matrix[i][j] > 0:\n                edges.append((i, j))\n    return edges\n```\n\n### 8. 清空（Clear）\n\n```python\ndef clear(self):\n    self.vertices = set()\n    self.adjacency_matrix = []\n```\n\n### 9. 获得邻接矩阵（Adjacency Matrix）\n\n```python\ndef get_adjacency_matrix(self):\n    return self.adjacency_matrix\n```\n\n### 10. 获得邻接表（Adjacency List）\n\n```python\ndef get_adjacency_list(self):\n    adjacency_list = {}\n    for i in range(len(self.vertices)):\n        adjacency_list[i] = []\n        for j in range(len(self.vertices)):\n            if self.adjacency_matrix[i][j] > 0:\n                adjacency_list[i].append(j)\n    return adjacency_list\n```\n\n### 11. 深度优先遍历（Depth First Traversal）\n\n```python\ndef depth_first_traversal(self, start_vertex):\n    visited = set()\n    self._depth_first_traversal(start_vertex, visited)\n\ndef _depth_first_traversal(self, vertex, visited):\n    visited.add(vertex)\n    print(vertex)\n    for v in self.get_adjacent_vertices(vertex):\n        if v not in visited:\n            self._depth_first_traversal(v, visited)\n```\n\n### 12. 广度优先遍历（Breadth First Traversal）\n\n```python\ndef breadth_first_traversal(self, start_vertex):\n    visited = set()\n    queue = [start_vertex]\n    visited.add(start_vertex)\n    while queue:\n        vertex = queue.pop(0)\n        print(vertex)\n        for v in self.get_adjacent_vertices(vertex):\n            if v not in visited:\n                queue.append(v)\n                visited.add(v)\n```\n\n## 图的遍历的基本操作示例\n\n```python\n# 创建一个图\ngraph = Graph()\n\n# 添加顶点\ngraph.add_vertex(0)\ngraph.add_vertex(1)\ngraph.add_vertex(2)\ngraph.add_vertex(3)\n\n# 添加边\ngraph.add_edge(0, 1)\ngraph.add_edge(0, 2)\ngraph.add_edge(1, 2)\ngraph.add_edge(2, 3)\n\n# 获得邻接点\nprint(graph.get_adjacent_vertices(0))\nprint(graph.get_adjacent_vertices(1))\nprint(graph.get_adjacent_vertices(2))\nprint(graph.get_adjacent_vertices(3))\n\n# 获得顶点数\nprint(graph.get_vertices())\n\n# 获得边数\nprint(graph.get_edges())\n\n# 清空图\ngraph.clear()\n\n# 获得邻接矩阵\nprint(graph.get_adjacency_matrix())\n\n# 获得邻接表\nprint(graph.get_adjacency_list())\n\n# 深度优先遍历\ngraph.add_vertex(0)\ngraph.add_vertex(1)\ngraph.add_vertex(2)\ngraph.add_vertex(3)",
    "comparison": "## 1. 深度优先搜索\n\n- 深度优先搜索，是一种用于遍历或搜索树或图的算法。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。\n\n- 深度优先搜索（DFS）可以用递归或栈来实现。\n\n- 当我们想找到特定类型的结点时，深度优先搜索很有用。\n\n## 2. 数组\n\n- 数组是一种线性数据结构，它可以存储一个固定大小的有序列表，数组的元素是可以通过索引来访问的。\n\n- 数组的索引是从0开始的，并且是连续的。\n\n- 数组的优点是快速访问元素，缺点是插入和删除元素比较慢。\n\n## 3. 链表\n\n- 链表是一种线性数据结构，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。\n\n- 链表的优点是插入和删除元素比较快，缺点是访问元素比较慢。\n\n## 4. 树\n\n- 树是一种非线性数据结构，它由一系列节点组成，每个节点包含一个数据元素和一个指向其他节点的指针。\n\n- 树的根节点是没有父节点的节点，每个节点最多有一个父节点。\n\n- 树的优点是插入和删除元素比较快，缺点是访问元素比较慢。\n\n## 5. 哈希表\n\n- 哈希表是一种线性数据结构，它可以存储一组键值对，并且可以通过键快速查找值。\n\n- 哈希表的键是唯一的，并且可以通过哈希函数来生成一个值。\n\n- 哈希表的优点是快速查找元素，缺点是插入和删除元素比较慢。\n\n## 6. 堆\n\n- 堆是一种树形数据结构，它可以存储一组元素，并且可以快速找到最大值或最小值。\n\n- 堆的根节点是最大值或最小值。\n\n- 堆的优点是快速查找最大值或最小值，缺点是插入和删除元素比较慢。\n\n## 7. 图\n\n- 图是一种非线性数据结构，它由一系列节点和边组成，每个节点和每个边都有一个数据元素。\n\n- 图的节点可以是无向的，也可以是有向的。\n\n- 图的优点是可以表示复杂的网络结构，缺点是查找元素比较慢。",
    "concept": "#### 深度优先搜索算法的基本思想\n\n深度优先搜索算法是从图的某个顶点出发，沿着当前顶点的边，递归的进行深度遍历，直到到达没有未被访问过的顶点为止。\n\n#### 深度优先搜索算法的基本步骤\n\n- 创建一个空栈，并将根节点入栈；\n- 从栈中弹出一个顶点，如果该顶点没有被访问过，则对其进行访问，并将与该顶点相邻的其他顶点入栈；\n- 重复上述过程，直到栈为空，搜索结束。\n\n#### 深度优先搜索算法的代码实现\n\n```c++\n#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nclass Graph {\nprivate:\n    int V; // 顶点数\n    vector<vector<int>> adj; // 邻接表\n    vector<bool> visited; // 标记顶点是否被访问过\n\npublic:\n    Graph(int v) : V(v), adj(v), visited(v, false) {}\n\n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n    }\n\n    void dfs(int v) {\n        stack<int> s;\n        s.push(v);\n        visited[v] = true;\n        while (!s.empty()) {\n            int u = s.top();\n            s.pop();\n            cout << u << \" \";\n            for (int w : adj[u]) {\n                if (!visited[w]) {\n                    s.push(w);\n                    visited[w] = true;\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Graph g(4);\n    g.addEdge(0, 1);\n    g.addEdge(0, 2);\n    g.addEdge(1, 2);\n    g.addEdge(2, 0);\n    g.addEdge(2, 3);\n    g.addEdge(3, 3);\n\n    cout << \"DFS Traversal: \";\n    g.dfs(2);\n    cout << endl;\n\n    return 0;\n}\n```\n\n#### 深度优先搜索算法的应用\n\n- 迷宫求解\n- 连通分量分解\n- 拓扑排序\n- 求解有向无环图的可达性\n- 求解有向无环图的强连通分量\n- 求解有向图的可达性\n- 求解有向图的强连通分量\n\n#### 深度优先搜索算法的优缺点\n\n优点：\n\n- 容易理解和实现\n- 适用于求解一些简单的问题\n\n缺点：\n\n- 可能出现栈溢出或者递归层数过深的问题\n- 不适用于求解大规模图的问题\n\n#### 深度优先搜索算法的适用场景\n\n- 需要找出所有满足条件的解\n- 需要在有限的时间内找到最优解\n- 需要在图中找出所有的路径\n- 需要在图中找出满足某种条件的路径\n- 需要在图中找出满足某种条件的所有顶点\n- 需要在图中找出满足某种条件的所有边\n- 需要在图中找出满足某种条件的所有环\n- 需要在图中找出满足某种条件的所有连通分量\n- 需要在图中找出满足某种条件的所有强连通分量\n- 需要在图中找出满足某种条件的所有强连通分量\n- 需要在图中找出满足某种条件的所有环\n- 需要在图中找出满足某种条件的所有环\n- 需要在图中找出满足某种条件的所有环\n- 需要在图中找出满足某种条件的所有环\n\n\n\n#### 深度优先搜索算法的复杂度分析\n\n- 时间复杂度：O(V + E)，其中V为图中顶点的个数，E为图中边的个数。\n- 空间复杂度：O(V)，其中V为图中顶点的个数。\n\n#### 深度优先搜索算法的类比\n\n- 类比为“手动操作”，深度优先搜索算法是一种手动操作的算法，它通过递归或者栈来实现。\n\n#### 深度优先搜索算法的可视化描述\n\n- 类比为一棵树的遍历，深度优先搜索算法可以类比为树的前序、中序、后序遍历。",
    "traversal": "## 深度优先搜索\n\n深度优先搜索（Depth-First-Search）算法又称作「深度优先遍历」，从根节点开始，沿着树的深度遍历树的节点。如果所有节点均被访问，则算法中止。\n\n### 深度优先搜索的遍历方式\n\n- 前序遍历：根节点 -> 左节点 -> 右节点\n- 中序遍历：左节点 -> 根节点 -> 右节点\n- 后序遍历：左节点 -> 右节点 -> 根节点\n\n### 深度优先搜索伪代码描述\n\n#### 前序遍历\n\n```js\nDFS(root) {\n    if (root == null) return;\n    visit(root);\n    DFS(root.left);\n    DFS(root.right);\n}\n```\n\n#### 中序遍历\n\n```js\nDFS(root) {\n    if (root == null) return;\n    DFS(root.left);\n    visit(root);\n    DFS(root.right);\n}\n```\n\n#### 后序遍历\n\n```js\nDFS(root) {\n    if (root == null) return;\n    DFS(root.left);\n    DFS(root.right);\n    visit(root);\n}\n```"
  }
}